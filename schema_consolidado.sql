-- SCHEMA CONSOLIDADO SOLIDGO (Manual Consolidation)
-- Generated by Antigravity on 2026-01-13

-- 1. EXTENSIONS & BASICS
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 2. CORE TABLES (from 001_initial_schema.sql)
-- Create users table (extends Supabase auth.users)
CREATE TABLE IF NOT EXISTS public.users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  name TEXT NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('admin', 'driver', 'montador', 'conferente', 'helper')), -- Expanded roles
  phone TEXT,
  must_change_password BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL
);

-- Create vehicles table
CREATE TABLE IF NOT EXISTS public.vehicles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  plate TEXT NOT NULL UNIQUE,
  model TEXT NOT NULL,
  capacity INTEGER,
  active BOOLEAN DEFAULT true
);

-- Create drivers table
CREATE TABLE IF NOT EXISTS public.drivers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  cpf TEXT, -- Made optional by 010_alter_drivers_cpf
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE SET NULL,
  active BOOLEAN DEFAULT true
);
CREATE INDEX IF NOT EXISTS idx_drivers_user_id ON drivers(user_id);

-- Create orders table
CREATE TABLE IF NOT EXISTS public.orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id_erp TEXT NOT NULL UNIQUE,
  customer_name TEXT NOT NULL,
  phone TEXT NOT NULL,
  address_json JSONB NOT NULL,
  items_json JSONB NOT NULL,
  total DECIMAL(10,2) NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('imported', 'assigned', 'delivered', 'returned')),
  observations TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  -- Additional fields from migrations
  numero_lancamento BIGINT,
  observacoes_publicas TEXT,
  observacoes_internas TEXT,
  quantidade_volumes INTEGER,
  etiquetas TEXT[]
);

-- Create teams_user table (Correct table name found in production)
CREATE TABLE IF NOT EXISTS public.teams_user (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    driver_user_id UUID NOT NULL REFERENCES public.users(id),
    helper_user_id UUID NOT NULL REFERENCES public.users(id),
    name TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create routes table
CREATE TABLE IF NOT EXISTS public.routes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  driver_id UUID NOT NULL REFERENCES drivers(id) ON DELETE CASCADE,
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE SET NULL,
  conferente TEXT, -- Legacy text field
  observations TEXT,
  status TEXT NOT NULL CHECK (status IN ('pending', 'in_progress', 'completed')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  -- Additional fields
  route_code VARCHAR(15) UNIQUE,
  team_id UUID REFERENCES public.teams_user(id) ON DELETE SET NULL,
  helper_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
  conferente_id UUID REFERENCES public.users(id) ON DELETE SET NULL
);

-- Create route_orders table
CREATE TABLE IF NOT EXISTS public.route_orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  route_id UUID NOT NULL REFERENCES routes(id) ON DELETE CASCADE,
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  sequence INTEGER NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('pending', 'delivered', 'returned')),
  delivery_observations TEXT,
  return_reason_id UUID,
  signature_url TEXT,
  delivered_at TIMESTAMP WITH TIME ZONE,
  returned_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  UNIQUE(route_id, order_id)
);

-- Create audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type TEXT NOT NULL,
    entity_id UUID NOT NULL,
    action TEXT NOT NULL,
    details JSONB,
    user_id UUID REFERENCES public.users(id),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- Create user_preferences table
CREATE TABLE IF NOT EXISTS public.user_preferences (
    user_id UUID NOT NULL REFERENCES public.users(id),
    pref_key TEXT NOT NULL,
    pref_value JSONB NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    PRIMARY KEY (user_id, pref_key)
);

-- Create route_conferences table
CREATE TABLE IF NOT EXISTS public.route_conferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    route_id UUID NOT NULL REFERENCES public.routes(id),
    status TEXT DEFAULT 'pending',
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    user_id UUID REFERENCES public.users(id),
    summary JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    resolved_at TIMESTAMP WITH TIME ZONE,
    resolved_by UUID REFERENCES public.users(id),
    resolution JSONB
);

-- Create route_conference_scans table
CREATE TABLE IF NOT EXISTS public.route_conference_scans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    route_conference_id UUID NOT NULL REFERENCES public.route_conferences(id) ON DELETE CASCADE,
    normalized_code TEXT NOT NULL,
    order_id UUID REFERENCES public.orders(id),
    product_code TEXT,
    volume_index INTEGER,
    volume_total INTEGER,
    matched BOOLEAN,
    scanned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create latest_route_conferences VIEW (identified as missing)
CREATE OR REPLACE VIEW public.latest_route_conferences AS
 SELECT DISTINCT ON (route_conferences.route_id) route_conferences.id,
    route_conferences.route_id,
    route_conferences.status,
    route_conferences.summary ->> 'result_ok' AS result_ok,
    route_conferences.started_at,
    route_conferences.completed_at,
    route_conferences.created_at,
    route_conferences.user_id,
    route_conferences.summary,
    route_conferences.resolved_at,
    route_conferences.resolved_by,
    route_conferences.resolution
   FROM route_conferences
  ORDER BY route_conferences.route_id, route_conferences.created_at DESC;

-- Grant permissions for the view
GRANT SELECT ON public.latest_route_conferences TO authenticated;


-- Create return_reasons table
CREATE TABLE IF NOT EXISTS public.return_reasons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reason TEXT NOT NULL UNIQUE,
  description TEXT
);

-- Create sync_logs table
CREATE TABLE IF NOT EXISTS public.sync_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  table_name TEXT NOT NULL,
  record_id TEXT NOT NULL,
  action TEXT NOT NULL CHECK (action IN ('insert', 'update', 'delete')),
  data JSONB NOT NULL,
  synced BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  synced_at TIMESTAMP WITH TIME ZONE
);

-- Create app_settings table (identified during validation)
CREATE TABLE IF NOT EXISTS public.app_settings (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_by UUID REFERENCES auth.users(id)
);

-- Create webhook_settings table (identified during validation)
CREATE TABLE IF NOT EXISTS public.webhook_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT NOT NULL,
  url TEXT NOT NULL,
  active BOOLEAN DEFAULT true,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- RLS for new tables
ALTER TABLE app_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE webhook_settings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "app_settings_select_authenticated" ON app_settings FOR SELECT USING (true);
CREATE POLICY "app_settings_modify_admin" ON app_settings FOR ALL USING (EXISTS (SELECT 1 FROM users u WHERE u.id = auth.uid() AND u.role = 'admin'));

CREATE POLICY "webhook_settings_select_authenticated" ON webhook_settings FOR SELECT USING (true);
CREATE POLICY "webhook_settings_modify_authenticated" ON webhook_settings FOR ALL USING (true);

ALTER TABLE teams_user ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE route_conferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE route_conference_scans ENABLE ROW LEVEL SECURITY;

CREATE POLICY "teams_user_select_authenticated" ON teams_user FOR SELECT USING (true);
CREATE POLICY "teams_user_modify_admin" ON teams_user FOR ALL USING (EXISTS (SELECT 1 FROM users u WHERE u.id = auth.uid() AND u.role = 'admin'));

CREATE POLICY "audit_logs_select_admin" ON audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM users u WHERE u.id = auth.uid() AND u.role = 'admin'));
CREATE POLICY "user_preferences_own" ON user_preferences FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "route_conferences_select" ON route_conferences FOR SELECT USING (true);
CREATE POLICY "route_conference_scans_select" ON route_conference_scans FOR SELECT USING (true);


-- 3. ASSEMBLY TABLES (from 026_create_assembly_tables.sql)
CREATE TABLE IF NOT EXISTS public.assembly_routes (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  admin_id UUID NOT NULL REFERENCES auth.users(id),
  status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed')),
  deadline DATE,
  observations TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.assembly_products (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  assembly_route_id UUID NOT NULL REFERENCES assembly_routes(id) ON DELETE CASCADE,
  order_id UUID NOT NULL REFERENCES orders(id),
  product_name VARCHAR(255) NOT NULL,
  product_sku VARCHAR(100),
  customer_name VARCHAR(255) NOT NULL,
  customer_phone VARCHAR(50),
  installation_address JSONB NOT NULL,
  assembly_date TIMESTAMP WITH TIME ZONE,
  installer_id UUID REFERENCES auth.users(id),
  status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'assigned', 'in_progress', 'completed', 'cancelled', 'returned')), -- Added returned
  completion_date TIMESTAMP WITH TIME ZONE,
  technical_notes TEXT,
  photos JSONB DEFAULT '[]',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. BASIC INDEXES
CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_routes_driver_id ON routes(driver_id);
CREATE INDEX IF NOT EXISTS idx_routes_route_code ON routes(route_code);
CREATE INDEX IF NOT EXISTS idx_assembly_products_status ON assembly_products(status);
CREATE INDEX IF NOT EXISTS idx_assembly_products_order ON assembly_products(order_id);

-- 5. RLS ENABLE & POLICIES
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE drivers ENABLE ROW LEVEL SECURITY;
ALTER TABLE vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE routes ENABLE ROW LEVEL SECURITY;
ALTER TABLE route_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE assembly_routes ENABLE ROW LEVEL SECURITY;
ALTER TABLE assembly_products ENABLE ROW LEVEL SECURITY;

-- Simple "Admins can do everything" policy example (Shortened for consolidation)
-- Real apps should copy the full 002_rls_policies.sql content here if needed detailed granular control.
-- For this consolidated dump, we ensure Admins have access:
CREATE POLICY "Admins all" ON users FOR ALL USING (EXISTS (SELECT 1 FROM users u WHERE u.id = auth.uid() AND u.role = 'admin'));
CREATE POLICY "Admins all drivers" ON drivers FOR ALL USING (EXISTS (SELECT 1 FROM users u WHERE u.id = auth.uid() AND u.role = 'admin'));
-- And basic read for others:
CREATE POLICY "Auth read orders" ON orders FOR SELECT USING (auth.role() = 'authenticated');

-- 6. FUNCTIONS & TRIGGERS

-- A. Utility Functions
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$function$;

-- B. Auth Functions
CREATE OR REPLACE FUNCTION public.mark_new_user_must_change_password()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.must_change_password := true;
  RETURN NEW;
END;
$function$;

-- C. Business Logic Functions
CREATE OR REPLACE FUNCTION public.prevent_duplicate_routing()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    active_route_info text;
    order_erp_id text;
BEGIN
    -- Get Order ERP ID for better error message
    SELECT order_id_erp INTO order_erp_id FROM orders WHERE id = NEW.order_id;

    -- 1. Check if order is already delivered
    IF EXISTS (SELECT 1 FROM orders WHERE id = NEW.order_id AND status = 'delivered') THEN
        RAISE EXCEPTION 'O pedido % já foi entregue e não pode ser roteirizado novamente.', order_erp_id;
    END IF;

    -- 2. Check if order is in another ACTIVE route
    SELECT r.name INTO active_route_info
    FROM route_orders ro
    JOIN routes r ON ro.route_id = r.id
    WHERE ro.order_id = NEW.order_id
      AND r.status IN ('pending', 'in_progress', 'ready')
      AND r.id != NEW.route_id
    LIMIT 1;

    IF active_route_info IS NOT NULL THEN
        RAISE EXCEPTION 'O pedido % já está ativo na rota "%". Remova-o da rota anterior antes de adicionar novamente.', order_erp_id, active_route_info;
    END IF;

    RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.sync_order_status_from_route()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- CENÁRIO 1: Motorista marcou ENTREGUE
    IF NEW.status = 'delivered' THEN
        UPDATE orders 
        SET status = 'delivered'
        WHERE id = NEW.order_id;
    
    -- CENÁRIO 2: Motorista DESFEZ a entrega
    ELSIF NEW.status = 'pending' AND OLD.status = 'delivered' THEN
        UPDATE orders 
        SET status = 'assigned' 
        WHERE id = NEW.order_id;

    -- CENÁRIO 3: Motorista marcou RETORNADO
    ELSIF NEW.status = 'returned' THEN
        UPDATE orders 
        SET status = 'assigned'
        WHERE id = NEW.order_id;
    END IF;

    RETURN NEW;
END;
$function$;

-- D. Create Triggers
CREATE TRIGGER update_assembly_products_updated_at
BEFORE UPDATE ON public.assembly_products
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_assembly_routes_updated_at
BEFORE UPDATE ON public.assembly_routes
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER check_duplicate_routing
BEFORE INSERT ON public.route_orders
FOR EACH ROW EXECUTE FUNCTION prevent_duplicate_routing();

CREATE TRIGGER trigger_sync_route_to_order
AFTER UPDATE ON public.route_orders
FOR EACH ROW EXECUTE FUNCTION sync_order_status_from_route();

CREATE TRIGGER trigger_mark_must_change_password
BEFORE INSERT ON public.users
FOR EACH ROW EXECUTE FUNCTION mark_new_user_must_change_password();


-- Sync Assembly Trigger (from 202601130900_fix_assembly_trigger_quantity.sql)
CREATE OR REPLACE FUNCTION public.sync_assembly_products_from_order()
RETURNS TRIGGER AS $$
DECLARE
    item jsonb;
    should_assemble boolean;
    order_has_keyword boolean;
    clean_sku text;
    clean_name text;
    normalized_obs text;
    qty int;
    current_count int;
    i int;
BEGIN
    normalized_obs := lower(coalesce(NEW.observacoes_internas, '') || ' ' || coalesce(NEW.observacoes_publicas, ''));
    order_has_keyword := normalized_obs LIKE '%*montagem*%';

    IF NEW.status != 'delivered' THEN
        RETURN NEW;
    END IF;

    IF NEW.items_json IS NULL OR jsonb_array_length(NEW.items_json) = 0 THEN
        RETURN NEW;
    END IF;

    FOR item IN SELECT * FROM jsonb_array_elements(NEW.items_json)
    LOOP
        should_assemble := (item->>'has_assembly')::text ~* '^(true|sim|1|yes|y)$' 
                        OR order_has_keyword;

        IF should_assemble THEN
            clean_sku := coalesce(item->>'sku', 'SKU-INDEF');
            clean_name := coalesce(item->>'name', 'Produto sem nome');
            qty := GREATEST(1, coalesce((item->>'purchased_quantity')::int, (item->>'quantity')::int, 1));

            SELECT COUNT(*) INTO current_count
            FROM public.assembly_products ap 
            WHERE ap.order_id = NEW.id 
            AND ap.product_sku = clean_sku;

            IF current_count < qty THEN
                FOR i IN 1..(qty - current_count) LOOP
                    INSERT INTO public.assembly_products (
                        order_id, product_name, product_sku, customer_name, customer_phone,
                        installation_address, status, created_at, updated_at
                    ) VALUES (
                        NEW.id, clean_name, clean_sku, NEW.customer_name, NEW.phone,
                        NEW.address_json, 'pending', NOW(), NOW()
                    );
                END LOOP;
            END IF;
        END IF;
    END LOOP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sync_assembly_from_order
AFTER INSERT OR UPDATE OF status, items_json
ON public.orders
FOR EACH ROW
EXECUTE FUNCTION public.sync_assembly_products_from_order();

-- 7. DEFAULT DATA
INSERT INTO return_reasons (reason, description) VALUES
  ('CUSTOMER_NOT_HOME', 'Customer not available at delivery address'),
  ('WRONG_ADDRESS', 'Address provided is incorrect'),
  ('BUSINESS_CLOSED', 'Business location was closed'),
  ('CUSTOMER_REFUSED', 'Customer refused to accept the order'),
  ('DAMAGED_PRODUCT', 'Product arrived damaged'),
  ('INCORRECT_PRODUCT', 'Product does not match order'),
  ('OTHER', 'Other reason not specified')
ON CONFLICT (reason) DO NOTHING;
